#AUTOGENERATED! DO NOT EDIT! File to edit: dev/12_segmentation_metrics.ipynb (unless otherwise specified).

__all__ = ['foreground_acc', 'dice', 'iou', 'mean_dice', 'sigmoid_mean_dice', 'softmax_mean_dice']

#Cell
from fastai.vision import *
from fastai.metrics import foreground_acc, dice

#Cell
def iou(input: torch.Tensor, targs: torch.Tensor, **kwargs)->Rank0Tensor:
    "Binary IOU"
    return dice(input, targs, iou=True, **kwargs)

#Cell
def _dice(input:Tensor, targs:Tensor, iou:bool=False,
          eps:float=1e-8, reduce:bool=True)->Rank0Tensor:
    "Dice coefficient metric for probas and binary target."
    n = targs.shape[0]
    input = input.view(n,-1).float()
    targs = targs.view(n,-1).float()
    intersect = (input * targs).sum(dim=1).float()
    union = (input+targs).sum(dim=1).float()
    if not iou: l = 2. * intersect / union
    else: l = intersect / (union-intersect+eps)
    l[union==0.] = 1.
    if reduce: return l.mean()
    else: return l

#Cell
def mean_dice(input, target, c, macro=True, **kwargs):
    "macro: mean of class dice, micro: mean of mean dice image (excluding class:0)"
    if macro:
        res = [_dice(input==ci, target==ci, reduce=True, **kwargs) for ci in range(1, c)]
        return torch.mean(tensor(res).to(input.device))
    else:
        res = [_dice(input==ci, target==ci, reduce=False, **kwargs) for ci in range(1, c)]
        return torch.stack(res).to(input.device).mean(0).mean()

#Cell
def _to_sigmoid_input(logits, threshold=0.5, exclude_void=True):
    "convert logits to preds with sigmoid and thresh, assumes void is excluded"
    sigmoid_input = logits.sigmoid()
    thresholded_input = sigmoid_input > threshold
    _, indices = torch.max(sigmoid_input, dim=1)
    if exclude_void: indices += 1
    values, _ = torch.max(thresholded_input, dim=1)
    preds = (values.float()*indices.float())
    return preds

#Cell
def sigmoid_mean_dice(input:Tensor, target:Tensor, threshold:float=0.5, **kwargs)->Rank0Tensor:
    "mean_dice with sigmoid output which doesn't predict background"
    c = input.size(1)+1
    input = _to_sigmoid_input(input, threshold)
    return mean_dice(input, target, c, **kwargs)

#Cell
def softmax_mean_dice(input:Tensor, target:Tensor, **kwargs)->Rank0Tensor:
    "mean_dice with softmax output which includes background prediction"
    c = input.size(1)
    input = input.argmax(1)
    return mean_dice(input, target, c, **kwargs)